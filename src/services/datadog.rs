// Generated by Github Copilot
use crate::models::github::{
    CopilotDotcomChat, CopilotDotcomPullRequests, CopilotIdeChat, CopilotIdeCodeCompletions,
    CopilotMetrics,
};
use anyhow::{anyhow, Result};
use serde_json::{json, Value};
use std::time::{SystemTime, UNIX_EPOCH};
use tracing::{error, info};

/// A Datadog client that uses the Datadog HTTP API to send metrics to EU region
pub struct DatadogClient {
    api_key: String,
    api_url: String,
}

impl DatadogClient {
    pub fn new(api_key: String) -> Self {
        // Only support EU region
        let api_url = "https://api.datadoghq.eu/api/v2/series".to_string();
        Self { api_key, api_url }
    }

    /// Sends metrics to Datadog
    pub fn send_metrics(&self, metrics: &[CopilotMetrics], namespace: &str) -> Result<()> {
        println!(
            "Starting send_metrics to Datadog: {} data points for namespace {}",
            metrics.len(),
            namespace
        );

        // Check if we're in test mode - don't send metrics to Datadog
        if std::env::var("MOCK_GITHUB_API").is_ok() {
            info!("Test mode: Skipping sending metrics to Datadog");
            return Ok(());
        }

        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("Time went backwards")
            .as_secs() as i64;

        info!(
            "Preparing to send metrics to Datadog EU API: {} data points",
            metrics.len()
        );

        let mut all_series = Vec::new();

        // For each metric date, convert to Datadog series
        for metric in metrics {
            let date = &metric.date;

            // Add enterprise-wide metrics
            all_series.push(self.create_series_point(
                &format!("{}.total_active_users", namespace),
                metric.total_active_users.unwrap_or(0) as f64,
                timestamp,
                vec![
                    format!("date:{}", date),
                    "source:github-copilot-metrics".to_string(),
                ],
            ));

            all_series.push(self.create_series_point(
                &format!("{}.total_engaged_users", namespace),
                metric.total_engaged_users.unwrap_or(0) as f64,
                timestamp,
                vec![
                    format!("date:{}", date),
                    "source:github-copilot-metrics".to_string(),
                ],
            ));

            // Add IDE code completions metrics
            if let Some(ref code_completions) = metric.copilot_ide_code_completions {
                let code_completions_series = self.prepare_ide_code_completions_metrics(
                    code_completions,
                    namespace,
                    date,
                    timestamp,
                );
                all_series.extend(code_completions_series);
            }

            // Add IDE chat metrics
            if let Some(ref ide_chat) = metric.copilot_ide_chat {
                let ide_chat_series =
                    self.prepare_ide_chat_metrics(ide_chat, namespace, date, timestamp);
                all_series.extend(ide_chat_series);
            }

            // Add dotcom chat metrics
            if let Some(ref dotcom_chat) = metric.copilot_dotcom_chat {
                let dotcom_chat_series =
                    self.prepare_dotcom_chat_metrics(dotcom_chat, namespace, date, timestamp);
                all_series.extend(dotcom_chat_series);
            }

            // Add dotcom pull requests metrics
            if let Some(ref dotcom_pr) = metric.copilot_dotcom_pull_requests {
                let pr_series =
                    self.prepare_dotcom_pr_metrics(dotcom_pr, namespace, date, timestamp);
                all_series.extend(pr_series);
            }
        }

        println!("Prepared {} series for Datadog", all_series.len());

        // Send metrics in chunks to avoid oversized requests
        for (i, chunk) in all_series.chunks(100).enumerate() {
            println!(
                "Sending chunk {} of {} series to Datadog",
                i + 1,
                chunk.len()
            );
            self.send_metrics_chunk(chunk)?;
            println!("Successfully sent chunk {} to Datadog", i + 1);
        }

        println!("IMPORTANT: Completed all Datadog API calls successfully - AFTER THIS MESSAGE, PROGRAM SHOULD CONTINUE TO TEAM METRICS");
        info!("Successfully sent all metrics to Datadog EU API");

        // Check if this is the enterprise metrics call (can tell by namespace structure)
        if !namespace.contains(".team.") {
            // This is the enterprise metrics call
            println!("ENTERPRISE METRICS CALL: Next should be team metrics. If you don't see team metrics logs, there's an issue");
        } else {
            // This is a team metrics call
            println!(
                "TEAM METRICS CALL for team: {}",
                namespace.split(".team.").last().unwrap_or("unknown")
            );
        }

        Ok(())
    }

    /// Sends a chunk of metrics to Datadog
    fn send_metrics_chunk(&self, series: &[Value]) -> Result<()> {
        println!("In send_metrics_chunk with {} series", series.len());

        // Build the final request body
        let request_body = json!({ "series": series });

        println!("About to send request to Datadog API URL: {}", self.api_url);

        // Send the request
        match ureq::post(&self.api_url)
            .set("Content-Type", "application/json")
            .set("DD-API-KEY", &self.api_key)
            .send_json(request_body)
        {
            Ok(_) => {
                println!("Successfully sent chunk to Datadog API");
                Ok(())
            }
            Err(e) => {
                println!("Error sending metrics chunk to Datadog: {:?}", e);
                Err(anyhow!(
                    "Failed to send metrics to Datadog API: {}",
                    e.to_string()
                ))
            }
        }
    }

    fn create_series_point(
        &self,
        metric_name: &str,
        value: f64,
        timestamp: i64,
        tags: Vec<String>,
    ) -> Value {
        json!({
            "metric": metric_name,
            "type": "GAUGE",
            "points": [
                {
                    "timestamp": timestamp,
                    "value": value
                }
            ],
            "tags": tags
        })
    }

    fn prepare_ide_code_completions_metrics(
        &self,
        completions: &CopilotIdeCodeCompletions,
        namespace: &str,
        date: &str,
        timestamp: i64,
    ) -> Vec<Value> {
        let mut series = Vec::new();
        let prefix = format!("{}.ide.code_completions", namespace);
        let base_tags = vec![
            format!("date:{}", date),
            "source:github-copilot-metrics".to_string(),
        ];

        // Add total engaged users
        series.push(self.create_series_point(
            &format!("{}.total_engaged_users", prefix),
            completions.total_engaged_users as f64,
            timestamp,
            base_tags.clone(),
        ));

        // Add language metrics
        if let Some(ref languages) = completions.languages {
            for language in languages {
                let lang_name = &language.name;
                let mut lang_tags = base_tags.clone();
                lang_tags.push(format!("language:{}", lang_name));

                series.push(self.create_series_point(
                    &format!("{}.languages.total_engaged_users", prefix),
                    language.total_engaged_users as f64,
                    timestamp,
                    lang_tags.clone(),
                ));

                if let Some(suggestions) = language.total_code_suggestions {
                    series.push(self.create_series_point(
                        &format!("{}.languages.total_code_suggestions", prefix),
                        suggestions as f64,
                        timestamp,
                        lang_tags.clone(),
                    ));
                }

                if let Some(acceptances) = language.total_code_acceptances {
                    series.push(self.create_series_point(
                        &format!("{}.languages.total_code_acceptances", prefix),
                        acceptances as f64,
                        timestamp,
                        lang_tags.clone(),
                    ));
                }

                if let Some(lines_suggested) = language.total_code_lines_suggested {
                    series.push(self.create_series_point(
                        &format!("{}.languages.total_code_lines_suggested", prefix),
                        lines_suggested as f64,
                        timestamp,
                        lang_tags.clone(),
                    ));
                }

                if let Some(lines_accepted) = language.total_code_lines_accepted {
                    series.push(self.create_series_point(
                        &format!("{}.languages.total_code_lines_accepted", prefix),
                        lines_accepted as f64,
                        timestamp,
                        lang_tags.clone(),
                    ));
                }
            }
        }

        // Add editor metrics
        if let Some(ref editors) = completions.editors {
            for editor in editors {
                let editor_name = &editor.name;
                let mut editor_tags = base_tags.clone();
                editor_tags.push(format!("editor:{}", editor_name));

                series.push(self.create_series_point(
                    &format!("{}.editors.total_engaged_users", prefix),
                    editor.total_engaged_users as f64,
                    timestamp,
                    editor_tags,
                ));
            }
        }

        series
    }

    pub fn prepare_ide_chat_metrics(
        &self,
        ide_chat: &CopilotIdeChat,
        namespace: &str,
        date: &str,
        timestamp: i64,
    ) -> Vec<Value> {
        let mut series = Vec::new();
        let prefix = format!("{}.ide.chat", namespace);
        let base_tags = vec![
            format!("date:{}", date),
            "source:github-copilot-metrics".to_string(),
        ];

        // Add total engaged users
        series.push(self.create_series_point(
            &format!("{}.total_engaged_users", prefix),
            ide_chat.total_engaged_users as f64,
            timestamp,
            base_tags.clone(),
        ));

        // Calculate totals across all editors and models
        let mut total_chats = 0;
        let mut total_chat_copy_events = 0;
        let mut total_chat_insertion_events = 0;

        // Add editor metrics
        if let Some(ref editors) = ide_chat.editors {
            for editor in editors {
                let editor_name = &editor.name;
                let mut editor_tags = base_tags.clone();
                editor_tags.push(format!("editor:{}", editor_name));

                series.push(self.create_series_point(
                    &format!("{}.editors.total_engaged_users", prefix),
                    editor.total_engaged_users as f64,
                    timestamp,
                    editor_tags.clone(),
                ));

                // Process model data for each editor
                if let Some(ref models) = editor.models {
                    for model in models {
                        // Add to totals
                        if let Some(chats) = model.total_chats {
                            total_chats += chats;
                        }
                        if let Some(copy_events) = model.total_chat_copy_events {
                            total_chat_copy_events += copy_events;
                        }
                        if let Some(insertion_events) = model.total_chat_insertion_events {
                            total_chat_insertion_events += insertion_events;
                        }

                        // Also send individual model metrics if needed
                        let model_name = &model.name;
                        let is_custom = if model.is_custom_model {
                            "true"
                        } else {
                            "false"
                        };

                        let mut model_tags = editor_tags.clone();
                        model_tags.push(format!("model:{}", model_name));
                        model_tags.push(format!("is_custom_model:{}", is_custom));

                        series.push(self.create_series_point(
                            &format!("{}.editors.models.total_engaged_users", prefix),
                            model.total_engaged_users as f64,
                            timestamp,
                            model_tags.clone(),
                        ));

                        if let Some(summaries) = model.total_pr_summaries_created {
                            series.push(self.create_series_point(
                                &format!("{}.editors.models.total_pr_summaries_created", prefix),
                                summaries as f64,
                                timestamp,
                                model_tags,
                            ));
                        }
                    }
                }
            }
        }

        // Get the P7S1 namespace from environment
        if let Ok(p7s1_namespace) = std::env::var("DATADOG_NAMESPACE_P7S1") {
            // Add the totals with the P7S1 namespace
            series.push(self.create_series_point(
                &format!("{}.copilot_ide_chat.total_chats", p7s1_namespace),
                total_chats as f64,
                timestamp,
                base_tags.clone(),
            ));

            series.push(self.create_series_point(
                &format!("{}.copilot_ide_chat.total_chat_copy_events", p7s1_namespace),
                total_chat_copy_events as f64,
                timestamp,
                base_tags.clone(),
            ));

            series.push(self.create_series_point(
                &format!(
                    "{}.copilot_ide_chat.total_chat_insertion_events",
                    p7s1_namespace
                ),
                total_chat_insertion_events as f64,
                timestamp,
                base_tags.clone(),
            ));
        }

        series
    }

    fn prepare_dotcom_chat_metrics(
        &self,
        chat: &CopilotDotcomChat,
        namespace: &str,
        date: &str,
        timestamp: i64,
    ) -> Vec<Value> {
        let mut series = Vec::new();
        let prefix = format!("{}.dotcom.chat", namespace);
        let base_tags = vec![
            format!("date:{}", date),
            "source:github-copilot-metrics".to_string(),
        ];

        // Add total engaged users
        series.push(self.create_series_point(
            &format!("{}.total_engaged_users", prefix),
            chat.total_engaged_users as f64,
            timestamp,
            base_tags.clone(),
        ));

        // Add model metrics if models are available
        if let Some(models) = &chat.models {
            for model in models {
                let model_name = &model.name;
                let is_custom = if model.is_custom_model {
                    "true"
                } else {
                    "false"
                };

                let mut model_tags = base_tags.clone();
                model_tags.push(format!("model:{}", model_name));
                model_tags.push(format!("is_custom_model:{}", is_custom));

                series.push(self.create_series_point(
                    &format!("{}.models.total_engaged_users", prefix),
                    model.total_engaged_users as f64,
                    timestamp,
                    model_tags.clone(),
                ));

                if let Some(total_chats) = model.total_chats {
                    series.push(self.create_series_point(
                        &format!("{}.models.total_chats", prefix),
                        total_chats as f64,
                        timestamp,
                        model_tags,
                    ));
                }
            }
        }

        series
    }

    fn prepare_dotcom_pr_metrics(
        &self,
        pr: &CopilotDotcomPullRequests,
        namespace: &str,
        date: &str,
        timestamp: i64,
    ) -> Vec<Value> {
        let mut series = Vec::new();
        let prefix = format!("{}.dotcom.pull_requests", namespace);
        let base_tags = vec![
            format!("date:{}", date),
            "source:github-copilot-metrics".to_string(),
        ];

        // Add total engaged users
        series.push(self.create_series_point(
            &format!("{}.total_engaged_users", prefix),
            pr.total_engaged_users as f64,
            timestamp,
            base_tags.clone(),
        ));

        // Add repository metrics if repositories are available
        if let Some(repositories) = &pr.repositories {
            for repo in repositories {
                let repo_name = &repo.name;
                let mut repo_tags = base_tags.clone();
                repo_tags.push(format!("repository:{}", repo_name));

                series.push(self.create_series_point(
                    &format!("{}.repositories.total_engaged_users", prefix),
                    repo.total_engaged_users as f64,
                    timestamp,
                    repo_tags.clone(),
                ));

                for model in &repo.models {
                    let model_name = &model.name;
                    let is_custom = if model.is_custom_model {
                        "true"
                    } else {
                        "false"
                    };

                    let mut model_tags = repo_tags.clone();
                    model_tags.push(format!("model:{}", model_name));
                    model_tags.push(format!("is_custom_model:{}", is_custom));

                    series.push(self.create_series_point(
                        &format!("{}.repositories.models.total_engaged_users", prefix),
                        model.total_engaged_users as f64,
                        timestamp,
                        model_tags.clone(),
                    ));

                    if let Some(summaries) = model.total_pr_summaries_created {
                        series.push(self.create_series_point(
                            &format!("{}.repositories.models.total_pr_summaries_created", prefix),
                            summaries as f64,
                            timestamp,
                            model_tags,
                        ));
                    }
                }
            }
        }

        series
    }
}
// Generated Code by Github Copilot ends here
