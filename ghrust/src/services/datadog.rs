// Generated by Github Copilot
use crate::models::github::{
    CopilotDotcomChat, CopilotDotcomPullRequests, CopilotIdeChat, CopilotIdeCodeCompletions,
    CopilotMetrics,
};
use anyhow::{anyhow, Result};
use serde_json::{json, Value};
use std::time::{SystemTime, UNIX_EPOCH};
use tracing::{error, info};

/// A Datadog client that uses the Datadog HTTP API to send metrics to EU region
pub struct DatadogClient {
    api_key: String,
    api_url: String,
}

impl DatadogClient {
    pub fn new(api_key: String) -> Self {
        // Only support EU region
        let api_url = "https://api.datadoghq.eu/api/v2/series".to_string();
        Self { api_key, api_url }
    }

    pub fn send_metrics(&self, metrics: &[CopilotMetrics], namespace: &str) -> Result<()> {
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("Time went backwards")
            .as_secs() as i64;

        info!(
            "Preparing to send metrics to Datadog EU API: {} data points",
            metrics.len()
        );

        let mut all_series = Vec::new();

        for metric in metrics {
            let date = &metric.date;
            let date_tag = format!("date:{}", date);
            let source_tag = "source:github-copilot-metrics".to_string();
            let tags = vec![date_tag, source_tag];

            // Add top-level metrics
            if let Some(total_active_users) = metric.total_active_users {
                all_series.push(self.create_series_point(
                    &format!("{}.total_active_users", namespace),
                    total_active_users as f64,
                    timestamp,
                    tags.clone(),
                ));
            }

            if let Some(total_engaged_users) = metric.total_engaged_users {
                all_series.push(self.create_series_point(
                    &format!("{}.total_engaged_users", namespace),
                    total_engaged_users as f64,
                    timestamp,
                    tags.clone(),
                ));
            }

            // Add IDE code completions metrics
            if let Some(ref ide_code_completions) = metric.copilot_ide_code_completions {
                let completions_series = self.prepare_ide_code_completions_metrics(
                    ide_code_completions,
                    namespace,
                    date,
                    timestamp,
                );
                all_series.extend(completions_series);
            }

            // Add IDE chat metrics
            if let Some(ref ide_chat) = metric.copilot_ide_chat {
                let chat_series =
                    self.prepare_ide_chat_metrics(ide_chat, namespace, date, timestamp);
                all_series.extend(chat_series);
            }

            // Add dotcom chat metrics
            if let Some(ref dotcom_chat) = metric.copilot_dotcom_chat {
                let dotcom_chat_series =
                    self.prepare_dotcom_chat_metrics(dotcom_chat, namespace, date, timestamp);
                all_series.extend(dotcom_chat_series);
            }

            // Add dotcom pull requests metrics
            if let Some(ref dotcom_pr) = metric.copilot_dotcom_pull_requests {
                let pr_series =
                    self.prepare_dotcom_pr_metrics(dotcom_pr, namespace, date, timestamp);
                all_series.extend(pr_series);
            }
        }

        // Send metrics in chunks to avoid oversized requests
        for chunk in all_series.chunks(100) {
            self.send_metrics_chunk(chunk)?;
        }

        info!("Successfully sent all metrics to Datadog EU API");
        Ok(())
    }

    fn send_metrics_chunk(&self, series: &[Value]) -> Result<()> {
        let payload = json!({
            "series": series
        });

        let response = ureq::post(&self.api_url)
            .set("DD-API-KEY", &self.api_key)
            .set("Content-Type", "application/json")
            .send_json(payload);

        match response {
            Ok(_) => Ok(()),
            Err(ureq::Error::Status(code, response)) => {
                let error_body = response
                    .into_string()
                    .unwrap_or_else(|_| "Unable to read error body".to_string());
                error!(
                    "Error sending metrics to Datadog API: HTTP {}: {}",
                    code, error_body
                );
                Err(anyhow!("Datadog API error: HTTP {}: {}", code, error_body))
            }
            Err(err) => {
                error!("Error sending metrics to Datadog API: {}", err);
                Err(anyhow!("Failed to send metrics to Datadog: {}", err))
            }
        }
    }

    fn create_series_point(
        &self,
        metric_name: &str,
        value: f64,
        timestamp: i64,
        tags: Vec<String>,
    ) -> Value {
        json!({
            "metric": metric_name,
            "type": "GAUGE",
            "points": [
                {
                    "timestamp": timestamp,
                    "value": value
                }
            ],
            "tags": tags
        })
    }

    fn prepare_ide_code_completions_metrics(
        &self,
        completions: &CopilotIdeCodeCompletions,
        namespace: &str,
        date: &str,
        timestamp: i64,
    ) -> Vec<Value> {
        let mut series = Vec::new();
        let prefix = format!("{}.ide.code_completions", namespace);
        let base_tags = vec![
            format!("date:{}", date),
            "source:github-copilot-metrics".to_string(),
        ];

        // Add total engaged users
        series.push(self.create_series_point(
            &format!("{}.total_engaged_users", prefix),
            completions.total_engaged_users as f64,
            timestamp,
            base_tags.clone(),
        ));

        // Add language metrics
        if let Some(ref languages) = completions.languages {
            for language in languages {
                let lang_name = &language.name;
                let mut lang_tags = base_tags.clone();
                lang_tags.push(format!("language:{}", lang_name));

                series.push(self.create_series_point(
                    &format!("{}.languages.total_engaged_users", prefix),
                    language.total_engaged_users as f64,
                    timestamp,
                    lang_tags.clone(),
                ));

                if let Some(suggestions) = language.total_code_suggestions {
                    series.push(self.create_series_point(
                        &format!("{}.languages.total_code_suggestions", prefix),
                        suggestions as f64,
                        timestamp,
                        lang_tags.clone(),
                    ));
                }

                if let Some(acceptances) = language.total_code_acceptances {
                    series.push(self.create_series_point(
                        &format!("{}.languages.total_code_acceptances", prefix),
                        acceptances as f64,
                        timestamp,
                        lang_tags.clone(),
                    ));
                }

                if let Some(lines_suggested) = language.total_code_lines_suggested {
                    series.push(self.create_series_point(
                        &format!("{}.languages.total_code_lines_suggested", prefix),
                        lines_suggested as f64,
                        timestamp,
                        lang_tags.clone(),
                    ));
                }

                if let Some(lines_accepted) = language.total_code_lines_accepted {
                    series.push(self.create_series_point(
                        &format!("{}.languages.total_code_lines_accepted", prefix),
                        lines_accepted as f64,
                        timestamp,
                        lang_tags.clone(),
                    ));
                }
            }
        }

        // Add editor metrics
        if let Some(ref editors) = completions.editors {
            for editor in editors {
                let editor_name = &editor.name;
                let mut editor_tags = base_tags.clone();
                editor_tags.push(format!("editor:{}", editor_name));

                series.push(self.create_series_point(
                    &format!("{}.editors.total_engaged_users", prefix),
                    editor.total_engaged_users as f64,
                    timestamp,
                    editor_tags,
                ));
            }
        }

        series
    }

    pub fn prepare_ide_chat_metrics(
        &self,
        ide_chat: &CopilotIdeChat,
        namespace: &str,
        date: &str,
        timestamp: i64,
    ) -> Vec<Value> {
        let mut series = Vec::new();
        let prefix = format!("{}.ide.chat", namespace);
        let base_tags = vec![
            format!("date:{}", date),
            "source:github-copilot-metrics".to_string(),
        ];

        // Add total engaged users
        series.push(self.create_series_point(
            &format!("{}.total_engaged_users", prefix),
            ide_chat.total_engaged_users as f64,
            timestamp,
            base_tags.clone(),
        ));

        // Calculate totals across all editors and models
        let mut total_chats = 0;
        let mut total_chat_copy_events = 0;
        let mut total_chat_insertion_events = 0;

        // Add editor metrics
        if let Some(ref editors) = ide_chat.editors {
            for editor in editors {
                let editor_name = &editor.name;
                let mut editor_tags = base_tags.clone();
                editor_tags.push(format!("editor:{}", editor_name));

                series.push(self.create_series_point(
                    &format!("{}.editors.total_engaged_users", prefix),
                    editor.total_engaged_users as f64,
                    timestamp,
                    editor_tags.clone(),
                ));

                // Process model data for each editor
                if let Some(ref models) = editor.models {
                    for model in models {
                        // Add to totals
                        if let Some(chats) = model.total_chats {
                            total_chats += chats;
                        }
                        if let Some(copy_events) = model.total_chat_copy_events {
                            total_chat_copy_events += copy_events;
                        }
                        if let Some(insertion_events) = model.total_chat_insertion_events {
                            total_chat_insertion_events += insertion_events;
                        }

                        // Also send individual model metrics if needed
                        let model_name = &model.name;
                        let is_custom = if model.is_custom_model {
                            "true"
                        } else {
                            "false"
                        };

                        let mut model_tags = editor_tags.clone();
                        model_tags.push(format!("model:{}", model_name));
                        model_tags.push(format!("is_custom_model:{}", is_custom));

                        series.push(self.create_series_point(
                            &format!("{}.editors.models.total_engaged_users", prefix),
                            model.total_engaged_users as f64,
                            timestamp,
                            model_tags.clone(),
                        ));

                        if let Some(summaries) = model.total_pr_summaries_created {
                            series.push(self.create_series_point(
                                &format!("{}.editors.models.total_pr_summaries_created", prefix),
                                summaries as f64,
                                timestamp,
                                model_tags,
                            ));
                        }
                    }
                }
            }
        }

        // Get the P7S1 namespace from environment
        if let Ok(p7s1_namespace) = std::env::var("DATADOG_NAMESPACE_P7S1") {
            // Add the totals with the P7S1 namespace
            series.push(self.create_series_point(
                &format!("{}.copilot_ide_chat.total_chats", p7s1_namespace),
                total_chats as f64,
                timestamp,
                base_tags.clone(),
            ));

            series.push(self.create_series_point(
                &format!("{}.copilot_ide_chat.total_chat_copy_events", p7s1_namespace),
                total_chat_copy_events as f64,
                timestamp,
                base_tags.clone(),
            ));

            series.push(self.create_series_point(
                &format!(
                    "{}.copilot_ide_chat.total_chat_insertion_events",
                    p7s1_namespace
                ),
                total_chat_insertion_events as f64,
                timestamp,
                base_tags.clone(),
            ));
        }

        series
    }

    fn prepare_dotcom_chat_metrics(
        &self,
        chat: &CopilotDotcomChat,
        namespace: &str,
        date: &str,
        timestamp: i64,
    ) -> Vec<Value> {
        let mut series = Vec::new();
        let prefix = format!("{}.dotcom.chat", namespace);
        let base_tags = vec![
            format!("date:{}", date),
            "source:github-copilot-metrics".to_string(),
        ];

        // Add total engaged users
        series.push(self.create_series_point(
            &format!("{}.total_engaged_users", prefix),
            chat.total_engaged_users as f64,
            timestamp,
            base_tags.clone(),
        ));

        // Add model metrics if models are available
        if let Some(models) = &chat.models {
            for model in models {
                let model_name = &model.name;
                let is_custom = if model.is_custom_model {
                    "true"
                } else {
                    "false"
                };

                let mut model_tags = base_tags.clone();
                model_tags.push(format!("model:{}", model_name));
                model_tags.push(format!("is_custom_model:{}", is_custom));

                series.push(self.create_series_point(
                    &format!("{}.models.total_engaged_users", prefix),
                    model.total_engaged_users as f64,
                    timestamp,
                    model_tags.clone(),
                ));

                if let Some(total_chats) = model.total_chats {
                    series.push(self.create_series_point(
                        &format!("{}.models.total_chats", prefix),
                        total_chats as f64,
                        timestamp,
                        model_tags,
                    ));
                }
            }
        }

        series
    }

    fn prepare_dotcom_pr_metrics(
        &self,
        pr: &CopilotDotcomPullRequests,
        namespace: &str,
        date: &str,
        timestamp: i64,
    ) -> Vec<Value> {
        let mut series = Vec::new();
        let prefix = format!("{}.dotcom.pull_requests", namespace);
        let base_tags = vec![
            format!("date:{}", date),
            "source:github-copilot-metrics".to_string(),
        ];

        // Add total engaged users
        series.push(self.create_series_point(
            &format!("{}.total_engaged_users", prefix),
            pr.total_engaged_users as f64,
            timestamp,
            base_tags.clone(),
        ));

        // Add repository metrics if repositories are available
        if let Some(repositories) = &pr.repositories {
            for repo in repositories {
                let repo_name = &repo.name;
                let mut repo_tags = base_tags.clone();
                repo_tags.push(format!("repository:{}", repo_name));

                series.push(self.create_series_point(
                    &format!("{}.repositories.total_engaged_users", prefix),
                    repo.total_engaged_users as f64,
                    timestamp,
                    repo_tags.clone(),
                ));

                for model in &repo.models {
                    let model_name = &model.name;
                    let is_custom = if model.is_custom_model {
                        "true"
                    } else {
                        "false"
                    };

                    let mut model_tags = repo_tags.clone();
                    model_tags.push(format!("model:{}", model_name));
                    model_tags.push(format!("is_custom_model:{}", is_custom));

                    series.push(self.create_series_point(
                        &format!("{}.repositories.models.total_engaged_users", prefix),
                        model.total_engaged_users as f64,
                        timestamp,
                        model_tags.clone(),
                    ));

                    if let Some(summaries) = model.total_pr_summaries_created {
                        series.push(self.create_series_point(
                            &format!("{}.repositories.models.total_pr_summaries_created", prefix),
                            summaries as f64,
                            timestamp,
                            model_tags,
                        ));
                    }
                }
            }
        }

        series
    }
}
// Generated Code by Github Copilot ends here
