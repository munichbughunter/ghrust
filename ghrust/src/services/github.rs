// Generated by Github Copilot
use crate::models::github::{
    CopilotDotcomChat, CopilotIdeChat, CopilotIdeCodeCompletions, CopilotMetrics, Language,
};
use anyhow::{anyhow, Result};
use chrono::{DateTime, Duration, Utc};
use std::env;
use tracing::error;

pub fn get_github_metrics(github_token: &str, enterprise_id: &str) -> Result<Vec<CopilotMetrics>> {
    // Calculate yesterday's date in ISO 8601 format
    let now: DateTime<Utc> = Utc::now();
    let yesterday = now - Duration::days(1);
    let since_date = yesterday.format("%Y-%m-%dT%H:%M:%SZ").to_string();

    let url = format!(
        "https://api.github.com/enterprises/{}/copilot/metrics",
        enterprise_id
    );

    let response = ureq::get(&url)
        .query("since", &since_date)
        .set("Accept", "application/vnd.github+json")
        .set("Authorization", &format!("Bearer {}", github_token))
        .set("X-GitHub-Api-Version", "2022-11-28")
        .call();

    match response {
        Ok(response) => {
            let response_text = response.into_string()?;
            println!("\nResponse Body:");
            println!("{}", response_text);
            println!("=======================\n");

            // Parse the text into JSON
            let metrics: Vec<CopilotMetrics> = match serde_json::from_str(&response_text) {
                Ok(metrics) => {
                    println!("\n=== Metrics for Datadog ===");
                    for metric in &metrics {
                        let metric: &CopilotMetrics = metric;
                        println!("Date: {}", metric.date);
                        if let Some(active) = metric.total_active_users {
                            println!("Total Active Users: {}", active);
                        }
                        if let Some(engaged) = metric.total_engaged_users {
                            println!("Total Engaged Users: {}", engaged);
                        }
                        if let Some(ref completions) = metric.copilot_ide_code_completions {
                            let completions: &CopilotIdeCodeCompletions = completions;
                            println!(
                                "IDE Code Completions Engaged Users: {}",
                                completions.total_engaged_users
                            );

                            if let Some(ref languages) = completions.languages {
                                println!("\nLanguage Breakdown:");
                                for lang in languages {
                                    let lang: &Language = lang;
                                    println!(
                                        "  {} - {} users",
                                        lang.name, lang.total_engaged_users
                                    );
                                }
                            }
                        }
                        if let Some(ref chat) = metric.copilot_ide_chat {
                            let chat: &CopilotIdeChat = chat;
                            println!("IDE Chat Engaged Users: {}", chat.total_engaged_users);
                        }
                        if let Some(ref chat) = metric.copilot_dotcom_chat {
                            let chat: &CopilotDotcomChat = chat;
                            println!("Dotcom Chat Engaged Users: {}", chat.total_engaged_users);
                        }
                        println!("------------------------");
                    }
                    println!("=======================\n");
                    metrics
                }
                Err(e) => {
                    error!("Failed to parse JSON response: {}", e);
                    return Err(anyhow!("Failed to read JSON: {}", e));
                }
            };
            Ok(metrics)
        }
        Err(ureq::Error::Status(403, _)) => {
            Err(anyhow!("Forbidden: Not authorized to access this resource"))
        }
        Err(ureq::Error::Status(404, _)) => {
            Err(anyhow!("Not Found: The requested resource does not exist"))
        }
        Err(ureq::Error::Status(422, _)) => Err(anyhow!(
            "Unprocessable Entity: Copilot Usage Metrics API setting is disabled"
        )),
        Err(ureq::Error::Status(status, response)) => {
            if let Ok(response_text) = response.into_string() {
                error!("Error response from GitHub API: {}", response_text);
            }
            Err(anyhow!("Error: Received status code: {}", status))
        }
        Err(e) => Err(anyhow!("Error fetching GitHub metrics: {}", e)),
    }
}
// Generated Code by Github Copilot ends here

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::github::{
        CopilotDotcomChat, CopilotDotcomPullRequests, CopilotIdeChat, CopilotIdeCodeCompletions,
        CopilotMetrics, Editor, Language, Model, Repository,
    };
    use std::cell::RefCell;
    use std::process::Command;
    use std::sync::{Arc, Mutex};

    // Introduce a mock server for tests
    struct MockServer {
        // We'll store expected responses in memory
        responses: RefCell<Vec<CopilotMetrics>>,
    }

    impl MockServer {
        fn new(metrics: Vec<CopilotMetrics>) -> Self {
            Self {
                responses: RefCell::new(metrics),
            }
        }

        // This would normally be a HTTP endpoint, but we'll just return the data directly
        fn get_metrics(&self, _token: &str, _enterprise_id: &str) -> Vec<CopilotMetrics> {
            self.responses.borrow().clone()
        }
    }

    // A more robust mock test that simulates the GitHub API
    #[test]
    fn test_github_api_with_mock() {
        // Create sample metrics for our mock
        let sample_metrics = vec![CopilotMetrics {
            date: "2023-03-01".to_string(),
            total_active_users: Some(1000),
            total_engaged_users: Some(800),
            copilot_ide_code_completions: Some(CopilotIdeCodeCompletions {
                total_engaged_users: 600,
                languages: Some(vec![Language {
                    name: "Rust".to_string(),
                    total_engaged_users: 300,
                    total_code_suggestions: Some(5000),
                    total_code_acceptances: Some(2500),
                    total_code_lines_suggested: Some(10000),
                    total_code_lines_accepted: Some(5000),
                }]),
                editors: Some(vec![Editor {
                    name: "VS Code".to_string(),
                    total_engaged_users: 550,
                    models: None,
                }]),
            }),
            copilot_ide_chat: Some(CopilotIdeChat {
                total_engaged_users: 400,
                editors: Some(vec![Editor {
                    name: "VS Code".to_string(),
                    total_engaged_users: 375,
                    models: None,
                }]),
            }),
            copilot_dotcom_chat: Some(CopilotDotcomChat {
                total_engaged_users: 300,
                models: Some(vec![Model {
                    name: "GPT-4".to_string(),
                    is_custom_model: false,
                    custom_model_training_date: None,
                    total_engaged_users: 290,
                    languages: None,
                    total_chats: Some(500),
                    total_chat_insertion_events: Some(300),
                    total_chat_copy_events: Some(200),
                    total_pr_summaries_created: None,
                }]),
            }),
            copilot_dotcom_pull_requests: Some(CopilotDotcomPullRequests {
                total_engaged_users: 200,
                repositories: Some(vec![Repository {
                    name: "sample-repo".to_string(),
                    total_engaged_users: 180,
                    models: vec![Model {
                        name: "GPT-4".to_string(),
                        is_custom_model: false,
                        custom_model_training_date: None,
                        total_engaged_users: 170,
                        languages: None,
                        total_chats: None,
                        total_chat_insertion_events: None,
                        total_chat_copy_events: None,
                        total_pr_summaries_created: Some(50),
                    }],
                }]),
            }),
        }];

        // Create a mock server with our sample data
        let mock_server = MockServer::new(sample_metrics.clone());

        // In a real implementation, we would use a crate like httptest or mockito
        // to intercept HTTP requests and return our mock responses

        // Just for this test, we'll directly access the mock data
        let result = mock_server.get_metrics("test-token", "test-enterprise");

        // Verify the results
        assert_eq!(result.len(), 1);
        assert_eq!(result[0].date, "2023-03-01");
        assert_eq!(result[0].total_active_users, Some(1000));
        assert_eq!(
            result[0]
                .copilot_ide_code_completions
                .as_ref()
                .unwrap()
                .total_engaged_users,
            600
        );
    }

    // This is a mock test that demonstrates how we would test the GitHub API client
    #[test]
    fn test_get_github_metrics_mock() {
        // Here we would use a mock server like mockito to simulate GitHub API responses
        // For demonstration purposes only
        let mock_metrics = vec![CopilotMetrics {
            date: "2023-03-01".to_string(),
            total_active_users: Some(1000),
            total_engaged_users: Some(800),
            copilot_ide_code_completions: Some(CopilotIdeCodeCompletions {
                total_engaged_users: 600,
                languages: Some(vec![Language {
                    name: "Rust".to_string(),
                    total_engaged_users: 300,
                    total_code_suggestions: Some(5000),
                    total_code_acceptances: Some(2500),
                    total_code_lines_suggested: Some(10000),
                    total_code_lines_accepted: Some(5000),
                }]),
                editors: Some(vec![Editor {
                    name: "VS Code".to_string(),
                    total_engaged_users: 550,
                    models: None,
                }]),
            }),
            copilot_ide_chat: Some(CopilotIdeChat {
                total_engaged_users: 400,
                editors: Some(vec![Editor {
                    name: "VS Code".to_string(),
                    total_engaged_users: 375,
                    models: None,
                }]),
            }),
            copilot_dotcom_chat: Some(CopilotDotcomChat {
                total_engaged_users: 300,
                models: Some(vec![Model {
                    name: "GPT-4".to_string(),
                    is_custom_model: false,
                    custom_model_training_date: None,
                    total_engaged_users: 290,
                    languages: None,
                    total_chats: Some(500),
                    total_chat_insertion_events: Some(300),
                    total_chat_copy_events: Some(200),
                    total_pr_summaries_created: None,
                }]),
            }),
            copilot_dotcom_pull_requests: Some(CopilotDotcomPullRequests {
                total_engaged_users: 200,
                repositories: Some(vec![Repository {
                    name: "sample-repo".to_string(),
                    total_engaged_users: 180,
                    models: vec![Model {
                        name: "GPT-4".to_string(),
                        is_custom_model: false,
                        custom_model_training_date: None,
                        total_engaged_users: 170,
                        languages: None,
                        total_chats: None,
                        total_chat_insertion_events: None,
                        total_chat_copy_events: None,
                        total_pr_summaries_created: Some(50),
                    }],
                }]),
            }),
        }];

        // In a real test, we would:
        // 1. Set up a mock server with proper response
        // 2. Make the actual API call
        // 3. Verify the results match what we expect

        // For now, just demonstrate what we would assert
        assert_eq!(mock_metrics.len(), 1);
        assert_eq!(mock_metrics[0].date, "2023-03-01");
        assert_eq!(mock_metrics[0].total_active_users, Some(1000));
        assert_eq!(
            mock_metrics[0]
                .copilot_ide_code_completions
                .as_ref()
                .unwrap()
                .total_engaged_users,
            600
        );
    }

    // This test shows how to test the full Lambda function locally
    // Note: This is just an example and won't actually run as written
    #[test]
    #[ignore] // Marked as ignored because it requires real credentials
    fn test_lambda_handler_integration() {
        // For a real integration test, we would:

        // 1. Set up test environment variables
        // std::env::set_var("GITHUB_TOKEN", "test-token");
        // std::env::set_var("GITHUB_ENTERPRISE_ID", "test-enterprise-id");
        // std::env::set_var("DATADOG_API_KEY", "test-api-key");

        // 2. Create a test event file
        // let event_json = r#"{
        //     "resource": "/",
        //     "path": "/",
        //     "httpMethod": "GET",
        //     ...
        // }"#;

        // 3. Invoke the Lambda function using cargo-lambda
        // let output = Command::new("cargo")
        //     .args(&["lambda", "invoke", "--data-stdin"])
        //     .stdin(event_json)
        //     .output()
        //     .expect("Failed to invoke Lambda");

        // 4. Check the response for success
        // assert!(String::from_utf8_lossy(&output.stdout).contains("success"));
    }

    #[test]
    fn test_github_api_direct() {
        // Load environment variables
        dotenv::dotenv().ok();

        // Get credentials from environment
        let github_token = env::var("GITHUB_TOKEN").expect("GITHUB_TOKEN not set");
        let enterprise_id = env::var("GITHUB_ENTERPRISE_ID").expect("GITHUB_ENTERPRISE_ID not set");

        // Make the actual API call
        let result = get_github_metrics(&github_token, &enterprise_id);
        println!("\nAPI Call Result: {:?}", result);
    }

    #[test]
    fn test_ide_chat_metrics_calculation() {
        // Set environment variable for testing
        std::env::set_var("DATADOG_NAMESPACE_P7S1", "gh.p7s1.test");

        // Create sample metrics with multiple editors and models
        let sample_metrics = vec![CopilotMetrics {
            date: "2023-03-01".to_string(),
            total_active_users: Some(100),
            total_engaged_users: Some(80),
            copilot_ide_chat: Some(CopilotIdeChat {
                total_engaged_users: 45,
                editors: Some(vec![
                    // Editor 1: JetBrains
                    Editor {
                        name: "JetBrains".to_string(),
                        total_engaged_users: 20,
                        models: Some(vec![Model {
                            name: "default".to_string(),
                            is_custom_model: false,
                            custom_model_training_date: None,
                            total_engaged_users: 20,
                            languages: None,
                            total_chats: Some(137),
                            total_chat_insertion_events: Some(39),
                            total_chat_copy_events: Some(44),
                            total_pr_summaries_created: None,
                        }]),
                    },
                    // Editor 2: VSCode
                    Editor {
                        name: "vscode".to_string(),
                        total_engaged_users: 25,
                        models: Some(vec![Model {
                            name: "default".to_string(),
                            is_custom_model: false,
                            custom_model_training_date: None,
                            total_engaged_users: 25,
                            languages: None,
                            total_chats: Some(298),
                            total_chat_insertion_events: Some(0),
                            total_chat_copy_events: Some(51),
                            total_pr_summaries_created: None,
                        }]),
                    },
                ]),
            }),
            // ... other fields set to None for brevity
            copilot_ide_code_completions: None,
            copilot_dotcom_chat: None,
            copilot_dotcom_pull_requests: None,
        }];

        // Initialize Datadog client (no actual API calls will be made)
        let datadog_client =
            crate::services::datadog::DatadogClient::new("test_api_key".to_string());

        // Get the series that would be sent to Datadog
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64;

        let namespace = "test.namespace";
        let date = "2023-03-01";

        let series = if let Some(ref chat) = sample_metrics[0].copilot_ide_chat {
            datadog_client.prepare_ide_chat_metrics(chat, namespace, date, timestamp)
        } else {
            vec![]
        };

        // Extract and print the totals for verification
        println!("Generated Datadog series:");

        let mut found_total_chats = false;
        let mut found_total_copy_events = false;
        let mut found_total_insertion_events = false;

        for series_point in &series {
            if let Some(metric_name) = series_point.get("metric").and_then(|m| m.as_str()) {
                if metric_name == "gh.p7s1.test.copilot_ide_chat.total_chats" {
                    found_total_chats = true;
                    if let Some(points) = series_point.get("points").and_then(|p| p.as_array()) {
                        if let Some(point) = points.first() {
                            if let Some(value) = point.get("value").and_then(|v| v.as_f64()) {
                                println!("Total chats: {}", value);
                                // Expected sum: 137 + 298 = 435
                                assert_eq!(value, 435.0);
                            }
                        }
                    }
                } else if metric_name == "gh.p7s1.test.copilot_ide_chat.total_chat_copy_events" {
                    found_total_copy_events = true;
                    if let Some(points) = series_point.get("points").and_then(|p| p.as_array()) {
                        if let Some(point) = points.first() {
                            if let Some(value) = point.get("value").and_then(|v| v.as_f64()) {
                                println!("Total chat copy events: {}", value);
                                // Expected sum: 44 + 51 = 95
                                assert_eq!(value, 95.0);
                            }
                        }
                    }
                } else if metric_name == "gh.p7s1.test.copilot_ide_chat.total_chat_insertion_events"
                {
                    found_total_insertion_events = true;
                    if let Some(points) = series_point.get("points").and_then(|p| p.as_array()) {
                        if let Some(point) = points.first() {
                            if let Some(value) = point.get("value").and_then(|v| v.as_f64()) {
                                println!("Total chat insertion events: {}", value);
                                // Expected sum: 39 + 0 = 39
                                assert_eq!(value, 39.0);
                            }
                        }
                    }
                }
                println!("Metric: {}", metric_name);
            }
        }

        // Ensure all metrics were generated
        assert!(found_total_chats, "Missing total_chats metric");
        assert!(
            found_total_copy_events,
            "Missing total_chat_copy_events metric"
        );
        assert!(
            found_total_insertion_events,
            "Missing total_chat_insertion_events metric"
        );
    }
}
